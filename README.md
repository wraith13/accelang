# &A ( Accelerator Language )

⚠ このプロジェクトは現状まだ企画段階であり、αレベルですらありません。

[名前だけ思いついてしまった](https://twitter.com/wraith13/status/923172054970507265)ので、とりあえず。
accelang ( 以下 &A と表記 ) は JSON 形式で記述する多目的マルチプラットフォーム言語(を目指している)。広義的には AltJS に該当するが、どちらかと言うと今現在必要としてる目的としては AltElectron であり、最終的にはスマフォなども動作対象プラットフォームとしてカバーしたいところ。

Electron は非常に便利なモノではあるが、造りが Web ブラウザであり、利用言語が JavaScript となってしまうこともあり、インストールを必要とする割には Web アプリと殆ど変わらないじゃないか！という残念なジレンマに陥っている。

&A の発想としては非Webアプリで利用するスクリプトであることを前提としつつも容易に Web ブラウザおよび Node.js 上でも動作させたい！　が、だからと言ってIT業界の現在進行形の黒歴史の一つである JavaScript は流石にいろいろな観点から避けたい！　というところが発想の起点のひとつであり、ネイティブバイナリ上あるいはネイティブバイナリそのものとして動作させることが主眼であり、そのあたりが JavaScript および Electron との根本的な違いのひとつとする。


## 言語名称

&A の命名は完全に冗談ではあるが &A を正式名称としつつ、検索性が悪くなることを意図した命名でもあるので検索性を鑑み公式のニックネームを accelang とし、それでも文章上は名前が短いことは一つの利点でもあるので、「accelang ( 以下 &A と表記 )」と言った形での運用を推奨。

> &A という表記はGUIのアクセラレーター由来であり[&]+[一文字]でアクセラレーターであり、 &A の A は Abyss の A 。

## 言語設計方針

* ダックタイピングを可能とするコンセプトベースの型システムとしてデザインし、静的検査を重視する。
* 一発で殆どのバグを直すのに十分な情報を含むエラー情報を提供できることを目指す。
* C++ のようなゼロオーバーヘッドは目指さない代わりに、&A言語システムおよび&Aプログラムのパフォーマンスを永続的に改善し続けられるように&A言語システムおよび&Aプログラムに対するプロファイラを提供する。
* できるだけ近代的な言語の便利な機能は一通り入れたいけど、まぁ、そのあたりはいろいろ状況を見つつ・・・
* 将来的な機能としたいが最初からその前提でいないと後からの導入は厳しいと思われるので、関数の360°実行を考慮した設計とする。恐らく、実際に使える状態にしておかないことには「考慮」が有名無実化することが予想されるので、完全でなくとも初期から関数の360°実行を対応を目指す。
* 動作速度プロファイラ、フットプリントプロファイラ、トレーサー、カバレッジ計測などの機能も言語の基本機能として提供する( v1 リリースの必須要件 )
* JITプログラミング周りもできれば対応したい・・・

## ソースコード概要

最終的には以下で述べる Gaia に統合したいが現状の都合からまずは Prometheus をベースとする。将来的に Prometheus は Deucalion と Gaia を結ぶ内部的な中間表現に留まる形にしたい。

### Gaia(フォーマルJSONソースコード)

* JSON形式での記述を前提とする。
* BASIC言語での中間表現的なモノに相当する。ただし、当言語においてはこれこそがマスターであり真のソースコードとして扱う。
* JSON形式なので当然全てのコードはコメントまで含めてデータとして記述する形になる。
* インタプリタやコンパイラを作成するに当たって原則としてJSON以外のパーザーを一切必要としないことを前提とする。
* JSON以外のパーザーを用意しないので、オブジェクト指向対応言語でよくある aaa.bbb.ccc と言った具合のメンバー参照の記述も [ "aaa", "bbb", "ccc" ] と言った具合( この表現自体は仮。実際にどのような形にするかはまだ思案中 )にパーザーを利用しない形での記述を要求する。
* プログラマによる読み書きは最終的には専用のエディタで行う形としたいが通常のテキストエディタでも可能なものとする。
* 通常のテキストエディタでも読み書き可能なものとするのは専用のエディタが存在しない現状の都合であって、プログラムによる読み書きのしやすさの方を優先する。

### Prometheus(シンプルJSONソースコード)

* JSON形式での記述を前提とする。
* Gaia ではあまりに冗長となる為、簡素且つ省略的な JSON での表現。
* Deucalion との違いは JSON 形式かプレーンテキスト形式かの違い。
* JSON形式なので当然全てのコードはコメントまで含めてデータとして記述する形になる。
* インタプリタやコンパイラを作成するに当たって原則としてJSON以外のパーザーを一切必要としないことを前提とする。
* JSON以外のパーザーを用意しないので、オブジェクト指向対応言語でよくある aaa.bbb.ccc と言った具合のメンバー参照の記述も [ "aaa", "bbb", "ccc" ] と言った具合( この表現自体は仮。実際にどのような形にするかはまだ思案中 )にパーザーを利用しない形での記述を要求する。
* Gaia とは異なりプログラマによる読み書きを優先する。

### Deucalion(プレーンテキストソースコード)

* プログラマ向けのプレーンテキスト形式。
* 専用のパーザーを必要とする。

## Uranus(メタデータ)

* JSON形式での記述を前提とする。
* プログラマが直接的に参照することは考慮しない。
* プロファイリングデータ
* カバレッジデータ
* 最終的にはBTSやVCSを内包することを考えたいが当面はその考慮すらしない

## 言語構文

```json
{ "&": "*", "*": [ "console", "log", { "Hello, &A!" } ] }
```

```json
{
    "&": "call",
    "target": {
        "&": "member",
        "scope": "console",
        "member": "log"
    },
    "params": {
        "text": {
            "&": "literal",
            "type": "string",
            "value": "Hello, &A!"
        }
    }
}
```

```json
{
    "&": "function",
    "name": "user-add",
    "results": {
        "result": {
            "&": "value",
            "type": "number"
        }
    },
    "params": {
        "a": {
            "&": "value",
            "type": "number"
        },
        "b": {
            "&": "value",
            "type": "number"
        }
    },
    "code": {
        "&": "let",
        "target": "result",
        "params": {
            "value": {
                "&": "call",
                "target": {
                    "scope": "system",
                    "name": "add"
                },
                "params": {
                    "a": {
                        "&": "value",
                        "name": "a"
                    },
                    "b": {
                        "&": "value",
                        "name": "b"
                    }
                }
            }
        }
    }
}
```

## 組み込み型

### any

### bool

### int

### float

### string

### array

### object

## 制御文

### if

### switch

### for

for-each な構文を前提にする

### while

### goto

### return

## 関数の種類

全ての関数は次のどちらかとなる。

### side_effectable

副作用を持ち 360°実行はできない関数。
side_effectable な関数内からは side_effectable な関数も reversible な関数も呼び出せる。

### reversible

副作用を持たない360°実行が可能な関数。
reversible な関数内では reversible な関数しか呼び出さない。

> 引数がなく定数を返す関数は扱いとしては reversible な関数になるが実用上は reversible である意味はほぼない。この関数を逆実行する際、正実行した場合に返す定数と同じ値を使って呼び出すとなにも起きず、異なる値を使って呼び出すと inconsistency exception が発生する。

> reversible のほうが default であるべきなので、指定としては side_effectable の場合に明示する形をできればとりたい。

### 関数呼び出し

### 関数定義

### クラス定義

## ライブラリ

### 標準ライブラリ

とりあえず、以下の系統を必要になったところから手をつけていく。実際に必要になったところの必要な部分だけ実装していく。

* 文字列系
* コレクション系
* 型情報系
* 数学系
* 標準入出力系
* 2D描画系
* ユーザー入力系
* GUI系

### パッケージシステム

パッケージシステムは肝のひとつだし、 GO の GitHub を利用するヤツとか筋がいいように思うけど、現状においては具体案なし。

## 当面のプラン

* まずは TypeScript によるインタープリターあるいはコンパイラ(to JavaScript)作成し、Webブラウザおよび Node.js での実行を可能な形にし、試行錯誤を繰り返す。
* TypeScript ベースのインタープリターおよびコンパイラがある程度落ち着いてきたら、 &A 自身によるインタプリタおよびコンパイラ(to JavaScript)を作成する。
* 最初の実用途としては、現在思案中の Windows 向けスクリーンセーバー用のスクリプトとして適用する。このスクリーンセーバーは、Webブラウザ上でスクリプトの作成および動作確認ができるようにする予定。スクリーンセーバーとしての実動作時はC++によって記述されたインタプリターによって動作させる(気が向けば Xbyak を利用したJITコンパイラで動作させる)。画面描画ライブラリには Skia を利用し、Webブラウザでの動作確認時には Canvas 2D を利用する。
* 当面は将来性を重視し、互換性には目を瞑り卓袱台返しを繰り返す。


## 関数の360°実行について

var x = add(a, b); と言った感じの加算する関数を var a = add(result:x, b); あるいは var { a, b } = add(result:x); などと言った形で呼び出せる機能。この場合、前者では加算関数ではなく減算関数として機能し、後者は a と b の片割れが別途確定したら値が確定する関係情報が返る。また、この後者の a と b を利用して add を普通に呼び出せば x が返ってくるという機能。

仮にこの機能がうまく実現できれば、エンコード関数の類いを書くだけで、デコード側はエンコード関数を逆実行すれば良いだけなる。

かなり野心的な機能なので、頓挫する可能性大。


## ライセンス

Boost Software License - Version 1.0 を採用しています。
詳細は [.\LICENSE_1_0.txt](./LICENSE_1_0.txt) を参照してください。

日本語参考訳: http://hamigaki.sourceforge.jp/doc/html/license.html

## バージョン採番ルール

### バージョン表記のフォーマット

`A.BB.CCC`

### メジャーバージョン番号(`A`)

明らかな非互換の変更が行われた際にインクリメント。
桁数は不定。

### マイナーバージョン番号(`BB`)

機能追加や上位互換と判断できる仕様変更が行われた際にインクリメント。
桁数は2桁固定。

### ビルド番号(`CCC`)

バグフィックスや仕様変更というほどでもない微細な修正が行われた際にインクリ
メント。
桁数は3桁固定。

### 細則

* 各番号は0始まりとする。
* 固定桁に足りない場合は先頭を0埋めする。
* 番号が固定桁で足りなくなった場合は、上位の番号をインクリメントする。
* 上位の番号がインクリメントされた場合、下位の番号は0にリセットする。
